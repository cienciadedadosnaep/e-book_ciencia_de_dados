---
output:
  pdf_document: default
  html_document: default
---
# Visualização e Análise gráfica na Ciência de dados {#capitulo-3}

O capítulo  \@ref(capitulo-2) apresenta a tabela como uma forma poderosa para estruturar e visualizar informações. No entanto, quando trabalhamos com enormes tabelas com uma imensa quantidade de linhas e colunas se torna difícil interpretar suas informações, não importa o quão organizadas elas estejam. Às vezes, é muito mais fácil interpretar essas informações através de gráficos, conteúdo que será ensinado no decorrer deste capítulo.

A construção e visualização gráfica é de extrema importância na área de ciência de dados, pois a partir de um bom gráfico podemos extrair ideias, hipóteses ou até conclusões a respeito de um tema. A importância da análise gráfica pode ser expressa por um ditado popular bastante conhecido: "Uma imagem vale por mil palavras".

O estudo de alguns tipos de gráficos apresentados neste capítulo utilizaram como objeto de estudo dados de turismo da cidade de Salvador, capital do estado da Bahia.

## 



Figuras e tabelas com títulos podem 
ser inseridas pelos respectivos ambientes
 `figure` e `table`.  

```{r eval=FALSE,echo=FALSE}

```

```{r nice-fig, fig.cap='Comportamento da pressão.', out.width='80%', fig.asp=.75, fig.align='center'}
par(mar = c(4, 4, .1, .1))
plot(pressure, type = 'b', pch = 19)
```

A forma de se referir pela figura é através 
do *label* do *chunck* no qual foi produzida
com prefixo `fig:`, e.g., ver Figura \@ref(fig:nice-fig). De forma similar, 
você pode se referir a tabelas geradas por `knitr::kable()`, e.g., ver Tabela \@ref(tab:nice-tab).

```{r nice-tab, tidy=FALSE}
knitr::kable(
  head(iris, 20), caption = 'Here is a nice table!',
  booktabs = TRUE
)
```

Você pode fazer citações, nós estamos usando o pacote **bookdown** [@R-bookdown] neste livro de amostra, o qual foi compilado por R Markdown e **knitr** [@xie2015].



## Analisando o uso de chunks





### Chunk - Condição padrão

A condição *default* do *rmarkdown*
é a execução do código, apresentação do 
código e do resultado do processamento. 

Criaremos inicialmente
uma função no R markdown:

```{r}
exps<-function(t,l,k,c){
 exps <- exp(-l*(k**(1-c))*t)
}
```
.

Em seguida, aplicaremos esta mesma 
função em um *chunck*:

```{r}
t<-seq(1,10,0.1)
l<-1e-5
c<-0.95
k<-350
Rb <- exps(t,l,k,c)
plot(t,Rb)
```


Como observado acima, os códigos e resultados 
são apresentados. 

### Aparecer código e sem executá-lo

Nesta seção utilizaremos a opção 
**eval=FALSE**, assim o código 
será apresentado sem executá-lo, 
ou seja, não haverá resultados.


```{r eval=FALSE}
exps<-function(t,l,k,c){
 exps <- exp(-l*(k**(1-c))*t)
}
```
.

Em seguida, aplicaremos esta mesma 
função em um *chunck*:

```{r eval=FALSE}
t<-seq(1,10,0.1)
l<-1e-5
c<-0.95
k<-350
Rb <- exps(t,l,k,c)
plot(t,Rb)
```


### Executar código sem apresentá-lo
Nesta seção utilizaremos a opção 
**echo=FALSE**, assim o código 
será apresentado sem executá-lo, 
ou seja, não haverá resultados.


```{r echo=FALSE}
exps<-function(t,l,k,c){
 exps <- exp(-l*(k**(1-c))*t)
}
```
.

Em seguida, aplicaremos esta mesma 
função em um *chunck*:

```{r echo=FALSE}
t<-seq(1,10,0.1)
l<-1e-5
c<-0.95
k<-350
Rb <- exps(t,l,k,c)
plot(t,Rb)
```
